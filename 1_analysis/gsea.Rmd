---
title: "Gene Set Enrichment Analysis"
author: "Ha Tran"
date: "2023-12-21"
output: html_document
editor_options: 
  markdown: 
    wrap: sentence
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  echo = TRUE,
  message = FALSE,
  warning = FALSE,
  eval = TRUE,
  fig.align = "center"
)
```

```{r load libraries}
# working with data
library(dplyr)
library(magrittr)
library(readr)
library(tibble)
library(reshape2)
library(tidyverse)
library(data.table)
library(RColorBrewer)

# Visualisation:
library(kableExtra)
library(ggplot2)
library(grid)
library(pander)
library(cowplot)
library(pheatmap)
library(DT)
library(extrafont)

# Custom ggplot
library(ggbiplot)
library(ggrepel)
library(plotly)

# Bioconductor packages:
library(GOSemSim)
library(fgsea)
library(edgeR)
library(limma)
library(Glimma)
library(clusterProfiler)
library(org.Mm.eg.db)
library(enrichplot)
library(KEGGREST)
library(rrvgo)
library(d3treeR)

library(ReactomePA)
library(pandoc)
library(knitr)
opts_knit$set(progress = FALSE, verbose = FALSE)
opts_chunk$set(warning=FALSE, message=FALSE, echo=FALSE)
```

```{r importData}
# load DGElist previously created in the set up
# dge <- readRDS(here::here("0_data/rds_objects/dge.rds"))
# fc <- readRDS(here::here("0_data/rds_objects/fc.rds"))
# fdr <- readRDS(here::here("0_data/rds_objects/fdr.rds"))
# lm <- readRDS(here::here("0_data/rds_objects/lm.rds"))
lm_all <- readRDS(here::here("0_data/rds_objects/lm_all.rds"))
# lm_sig <- readRDS(here::here("0_data/rds_objects/lm_sig.rds"))

# to increase the knitting speed. change to T to save all plots
savePlots <- F
export <- F
```

```{r importFunctions}
# Theme
bossTheme <- readRDS(here::here("0_data/functions/bossTheme.rds"))
bossTheme_bar <- readRDS(here::here("0_data/functions/bossTheme.rds"))
groupColour <- readRDS(here::here("0_data/functions/groupColour.rds"))
groupColour_dark <- readRDS(here::here("0_data/functions/groupColour_dark.rds"))
expressionCol <- readRDS(here::here("0_data/functions/expressionCol.rds"))
expressionCol_dark <- readRDS(here::here("0_data/functions/expressionCol_dark.rds"))

DT <- readRDS(here::here("0_data/functions/DT.rds"))

# Plotting
convert_to_superscript <- readRDS(here::here("0_data/functions/convert_to_superscript.rds"))
exponent <- readRDS(here::here("0_data/functions/exponent.rds"))
format_y_axis <- readRDS(here::here("0_data/functions/format_y_axis.rds"))
```

# Gene set enrichment analysis (GSEA)

In the study of gene expression profiles, a common method involves identifying genes that show significant differences.
The Over-Representation Analysis (ORA) enrichment analysis relies on these differentially expressed genes.
However, this approach may miss cases where small but consistent changes occur in a set of related genes.
Gene Set Enrichment Analysis (GSEA) directly addresses this limitation by considering all genes.

In GSEA, genes are ranked based on their phenotypic impact.
The goal is to determine whether a pre-defined set of genes (S), such as those sharing the same Gene Ontology (GO) category, is randomly distributed throughout the ranked list of genes (L) or concentrated at the top or bottom.

**In our case, the ranked list of genes (L) are generated by sorting all `r nrow(lm_all[[1]])` genes based on their expression levels (logFC)**

**The pre-defined set of genes (S) are the genes sharing the same GO, KEGG, or Reactome terms/pathways**

<details>

<summary>GSEA methodology</summary>

The GSEA method involves three key elements:

**Calculation of Enrichment Score (ES):** The ES quantifies how over-represented a set S is at the top or bottom of the ranked list L.
It is computed by moving down the list L, incrementing a running-sum statistic when a gene in S is encountered and decrementing when it is not.
The magnitude of the increment depends on gene statistics, such as the correlation of the gene with the phenotype.
The ES corresponds to the maximum deviation from zero in this process, akin to a weighted Kolmogorov-Smirnov (KS)-like statistic.

**Estimation of Significance Level of ES:** The p-value of the ES is determined through a permutation test.
Gene labels in the list L are randomly permuted, and the ES for the gene set is recomputed for the permuted data, generating a null distribution for the ES.
The observed ES's p-value is then calculated relative to this null distribution.

**Adjustment for Multiple Hypothesis Testing:** When evaluating entire gene sets, the estimated significance level is adjusted to account for multiple hypothesis testing.
Additionally, q-values are computed for controlling False Discovery Rate (FDR).

</details>



```{r gseaGO , eval=FALSE}
goSummaries <- url("https://uofabioinformaticshub.github.io/summaries2GO/data/goSummaries.RDS") %>%
  readRDS()
minPath <- 3

mmGO <- godata('org.Mm.eg.db', ont="BP")

geneList = lm_all[[1]]$logFC
names(geneList) = as.character(lm_all[[1]]$entrezid)
geneList = sort(geneList, decreasing = TRUE)

set.seed(1)
gsea_go <- gseGO(geneList      = geneList,
                 OrgDb         = org.Mm.eg.db,
                 ont           = "ALL",
                 minGSSize     = 100,
                 maxGSSize     = 500,
                 pvalueCutoff  = 0.05,
                 pAdjustMethod = "fdr",
                 verbose       = FALSE)


gsea_go <- pairwise_termsim(gsea_go,method = "Wang",semData = mmGO, showCategory = nrow(gsea_go@result))

gsea_go <- gsea_go %>% 
  clusterProfiler::setReadable(OrgDb = org.Mm.eg.db, keyType = "auto")

gsea_go@result <- gsea_go@result %>% dplyr::filter(p.adjust <= 0.05) %>% as.data.frame() %>% 
  separate(leading_edge, into = c("tags", "list", "signal"), sep = ",\\s*")
gsea_go@result$tags <- as.numeric(gsub("\\D", "", gsea_go@result$tags))
gsea_go@result$list <- as.numeric(gsub("\\D", "", gsea_go@result$list))
gsea_go@result$signal <- as.numeric(gsub("\\D", "", gsea_go@result$signal))

gsea_go@result <- gsea_go@result %>%
  as.data.frame() %>%
  rownames_to_column("id") %>%
  left_join(goSummaries) %>%
  dplyr::filter(shortest_path >= minPath) %>%
  column_to_rownames("id")

# adjust go results, separate compound column, add FDR column, adjust the GeneRatio column
gsea_go@result <- gsea_go@result %>% 
  dplyr::mutate(tags = tags/100,
                list = list/100,
                signal = signal/100,
                Count = tags * setSize,
                logFDR = -log(p.adjust, 10)) 

# at the beginnning of a word (after 35 characters), add a newline. shorten the y axis for dot plot

gsea_go@result$Description <- gsea_go@result$Description %>% str_to_sentence()

gsea_go@result$Description <- sub(pattern = "(.{1,45})(?:$| )",
                               replacement = "\\1\n",
                               x = gsea_go@result$Description)

# # remove the additional newline at the end of the string
gsea_go@result$Description <- sub(pattern = "\n$",
                               replacement = "",
                               x = gsea_go@result$Description)


saveRDS(gsea_go, here::here("0_data/rds_objects/gsea_go.rds"))

```

```{r semanticSim, eval=FALSE}
simMatrix <- calculateSimMatrix(gsea_go@result$ID,
                                orgdb="org.Mm.eg.db",
                                ont="BP",
                                method="Wang")

scores <- setNames(-log10(gsea_go@result$p.adjust), gsea_go@result$ID)

reducedTerms <- reduceSimMatrix(simMatrix,
                                scores,
                                threshold=0.7,
                                orgdb="org.Mm.eg.db") 

reducedTerms$parentTerm <- reducedTerms$parentTerm %>% str_to_sentence()
reducedTerms$parentTerm <- sub(pattern = "(.{1,35})(?:$| )", replacement = "\\1\n", x = reducedTerms$parentTerm)
reducedTerms$parentTerm <- sub(pattern = "\n$", replacement = "", x = reducedTerms$parentTerm)

reducedTerms$term <- reducedTerms$term %>% str_to_sentence()
reducedTerms$term <- sub(pattern = "(.{1,35})(?:$| )", replacement = "\\1\n", x = reducedTerms$term)
reducedTerms$term <- sub(pattern = "\n$", replacement = "", x = reducedTerms$term)


saveRDS(simMatrix, here::here("0_data/rds_objects/simMatrix.rds"))
saveRDS(scores, here::here("0_data/rds_objects/scores.rds"))
saveRDS(reducedTerms, here::here("0_data/rds_objects/reducedTerms.rds"))
```

```{r gseaKEGG, eval=FALSE}
set.seed(1)
gsea_kegg <- gseKEGG(geneList      = geneList,
                     organism      = "mmu",
                     keyType       = "kegg",
                     minGSSize     = 10,
                     maxGSSize     = 500,
                     pvalueCutoff  = 0.05,
                     pAdjustMethod = "fdr",
                     verbose       = FALSE)

gsea_kegg <- pairwise_termsim(gsea_kegg)

gsea_kegg <- gsea_kegg %>% 
  clusterProfiler::setReadable(OrgDb = org.Mm.eg.db, keyType = "ENTREZID")

gsea_kegg@result <- gsea_kegg@result %>% dplyr::filter(p.adjust <= 0.05) %>% as.data.frame() %>% 
  separate(leading_edge, into = c("tags", "list", "signal"), sep = ",\\s*")
gsea_kegg@result$tags <- as.numeric(gsub("\\D", "", gsea_kegg@result$tags))
gsea_kegg@result$list <- as.numeric(gsub("\\D", "", gsea_kegg@result$list))
gsea_kegg@result$signal <- as.numeric(gsub("\\D", "", gsea_kegg@result$signal))

gsea_kegg@result <- gsea_kegg@result %>% 
  dplyr::mutate(tags = tags/100,
                list = list/100,
                signal = signal/100,
                Count = tags * setSize,
                logFDR = -log(p.adjust, 10))

gsea_kegg@result$Description <- sub(pattern = " \\- Mus musculus \\(house mouse\\)",
                                 replacement = "",
                                 x = gsea_kegg@result$Description)

# at the beginnning of a word (after 45 characters), add a newline. shorten the y axis for dot plot
gsea_kegg@result$Description <- sub(pattern = "(.{1,45})(?:$| )",
                                 replacement = "\\1\n",
                                 x = gsea_kegg@result$Description)

# remove the additional newline at the end of the string
gsea_kegg@result$Description <- sub(pattern = "\n$",
                                 replacement = "",
                                 x = gsea_kegg@result$Description)

gsea_kegg@result$Description <- gsea_kegg@result$Description %>% str_to_sentence()


uniq_id <- rownames(gsea_kegg@result) %>% as.data.frame 
id_groups <- split(uniq_id$., (seq_along(uniq_id$.) - 1) %/% 10 + 1)

pathways <- flatten(map(id_groups, ~keggGet(.x)))

# Extract relevant information and create a data frame
pathways_details <- map_df(pathways, ~{
  kegg_id <- .$ENTRY
  data.frame(
    "kegg.id" = kegg_id,
    "path" = .$PATHWAY_MAP,
    "class" = if ("CLASS" %in% names(.)) .$CLASS else NA,
    "path.des" = if ("DESCRIPTION" %in% names(.)) toString(.$DESCRIPTION) else NA,
    "rel.path" = if ("REL_PATHWAY" %in% names(.)) toString(.$REL_PATHWAY) else NA,
    "ref" = if ("REFERENCE" %in% names(.)) {
      ref <- do.call("rbind", .$REFERENCE) %>% as.data.frame()
      toString(ref$REFERENCE)
    } else NA
  )
}) 

pathways_details$ref <- gsub("PMID:","",pathways_details$ref)
colnames(pathways_details) <- c("KEGG ID","Pathway","Class","Pathway description","Related pathways","References (PMID)")

gsea_kegg@result <- cbind(gsea_kegg@result,pathways_details[pathways_details$`KEGG ID` %in% rownames(gsea_kegg@result),3:6]) %>% 
  separate(Class, into = c("Class I", "Class II"), sep = ";\\s*")

saveRDS(gsea_kegg, here::here("0_data/rds_objects/gsea_kegg.rds"))
```

```{r gseaReactome, eval=FALSE}
set.seed(1)
gsea_react <- gsePathway(geneList, 
                         pvalueCutoff = 0.1,
                         pAdjustMethod = "fdr", 
                         organism = "mouse",
                         minGSSize = 10,
                         maxGSSize = 500,
                         verbose = FALSE)

gsea_react <- pairwise_termsim(gsea_react)

gsea_react <- gsea_react %>% 
  clusterProfiler::setReadable(OrgDb = org.Mm.eg.db, keyType = "ENTREZID")

gsea_react@result <- gsea_react@result  %>% as.data.frame() %>% 
  separate(leading_edge, into = c("tags", "list", "signal"), sep = ",\\s*")
gsea_react@result$tags <- as.numeric(gsub("\\D", "", gsea_react@result$tags))
gsea_react@result$list <- as.numeric(gsub("\\D", "", gsea_react@result$list))
gsea_react@result$signal <- as.numeric(gsub("\\D", "", gsea_react@result$signal))

gsea_react@result <- gsea_react@result %>% 
  dplyr::mutate(tags = tags/100,
                list = list/100,
                signal = signal/100,
                Count = tags * setSize,
                logFDR = -log(p.adjust, 10))

gsea_react@result$Description <- sub(pattern = "Regulation of Insulin-like Growth Factor \\(IGF\\) transport and uptake by Insulin-like Growth Factor Binding Proteins \\(IGFBPs\\)",
                                               replacement = "Regulation of IGF transport and uptake by IGFBPs", 
                                               x = gsea_react@result$Description)

# at the beginnning of a word (after 45 characters), add a newline. shorten the y axis for dot plot
gsea_react@result$Description <- sub(pattern = "(.{1,45})(?:$| )",
                                 replacement = "\\1\n",
                                 x = gsea_react@result$Description)

# remove the additional newline at the end of the string
gsea_react@result$Description <- sub(pattern = "\n$",
                                 replacement = "",
                                 x = gsea_react@result$Description)

gsea_react@result$Description <- gsea_react@result$Description %>% str_to_sentence()

saveRDS(gsea_react, here::here("0_data/rds_objects/gsea_react.rds"))
```

## Visualisation {.tabset .tabset-pills}

-   **Dot plot:** illustrates the top enriched GSEA terms/pathways.

    -   $Gene ratio =$ the number of gene in the term / the total of number of genes in the term. Indicated by the size
    -   The shapes represents the three main GO categories, either BP, MP, or CC

-   **Table:** list of all the significant GO terms

    -   See interpretation of GSEA results (below) for more details

-   **Enrichment plot:** represents the enrichment score (ES) across a ranked list of genes.
    The plot provides insights into how a particular gene set is distributed in the ranked list, indicating its association with a specific phenotype or biological condition.

    -   See interpretation of enrichment plot for more details



<details>

<summary>**Interpretation of GSEA results**</summary>

GSEA computes key statistics for gene set enrichment analysis:

**Enrichment Score (ES):**

Indicates the extent to which a gene set S (i.e. genes associated with a specific GO term) is overrepresented at the top or bottom of a ranked gene list L (all genes in the analysis, ranked from highest to lowest logFC).
GSEA calculates the ES by walking through the gene list, incrementing a running-sum statistic for genes in the set and decrementing for those not.
The magnitude depends on gene-phenotype correlation, with the ES representing the maximum deviation from zero.
A positive ES signifies enrichment at the top, while a negative ES indicates enrichment at the bottom of the ranked list.

**Normalized Enrichment Score (NES):**

Facilitates comparison of enrichment results across gene sets by normalizing ES.

$$
NES = \frac{actual\ ES}{mean\,(ESs\ against\ all\ permutations\ of\ the\ dataset)}
$$

**False Discovery Rate (FDR):**

Estimated probability that a gene set with a given NES represents a false positive finding.
Typically, a 25% FDR cutoff is suitable due to expression dataset variability.
However, in analyses with few samples and gene_set permutation, a stricter FDR cutoff (e.g., 5%) is recommended.

**Nominal P Value:**

The nominal p-value assesses the significance of an enrichment score for a single gene set, but for multiple sets, correction for gene set size and multiple hypothesis testing is essential.
Unadjusted p-values have limited value for comparing gene sets.
The false discovery rate (FDR) adjusts for these factors, providing a more robust measure of significance.

A low nominal p-value with a high FDR suggests lower significance compared to other gene sets, possibly due to sample limitations or poorly representative gene sets.
Conversely, a high nominal p-value with a low FDR indicates a less significant gene set.
A reported p-value of 0.0 in GSEA signifies an actual p-value less than 1/number-of-permutations, and increasing permutations (typically 1000) improves accuracy, avoiding potential memory issues in GSEA.

</details>



<details>

<summary>**Interpretation of enrichment plot**</summary>

[figure/gsea.Rmd/GSEA_plot.jpg]

**Running ES:**

-   The top portion of the plot displays the running Enrichment Score (ES) as the analysis progresses down the ranked list of genes.

-   The peak of the plot, where the ES reaches its maximum deviation from zero, represents the point of maximum enrichment for the gene set in the ranked list.

-   A positive ES indicates enrichment at the top of the ranked list, while a negative ES indicates enrichment at the bottom.

**Gene Set Members in the Ranked List:**

-   The middle portion of the plot indicates where the members of the gene set are located in the ranked list of genes.

-   This helps identify the specific genes contributing to the enrichment signal.

**Ranking List Metric:**

-   The bottom portion of the plot shows the values of the ranking metric as the analysis moves down the list of ranked genes.

-   The ranking metric measures a gene's correlation with the phenotype being studied.

-   Positive values indicate correlation with the first phenotype, while negative values indicate correlation with the second phenotype.
    For continuous phenotypes, positive values correlate with the phenotype profile, and negative values imply no correlation or inverse correlation.

**Leading Edge Subset:**

-   The leading edge subset is the set of gene set members that contribute most to the enrichment signal.

-   For a positive ES, the leading edge subset includes genes appearing in the ranked list prior to the peak score.
    For a negative ES, it includes genes appearing after the peak score.

</details>



**Semantic similarity plots - GO specific**

Due to the hierarchical structure of Gene Ontologies, the enriched sets generated often exhibit redundancy and pose challenges in interpretation.
The subsequent analyses and visualizations seek to alleviate this redundancy in GO sets by grouping comparable terms based on their semantic similarity.
The underlying concept behind measuring semantic similarity is grounded in the idea that genes sharing similar functions should possess analogous annotation vocabulary and exhibit close relationships within the ontology structure.

NOTE: the following semantic similarity analyses are performed using Graph-based method (Wang et al. 2007)

-   **Dendrogram plot:** performs hierarchical clustering on the semantic similarity of GO terms.

    -   NOTE: to maintain readability, only the top 50 most significant GO terms are clustered. These clusters are then divided into 9 clades and labeled using the top 4 high-frequency words.

-   **Scatter plot:** illustrates the UMAP space between semantically similar significant GO terms

    -   Distances represent the similarity between terms,
    -   Size represents the significance (in $-\log_{10}FDR$))
    -   NOTE: to maintain reability, only the top 15 most significant parent terms are labeled. Parent terms are the most significant term in a particular cluster

-   **Treemap plot:** Visualise the of hierarchical structures of semantically similar GO terms.

    -   The terms are colored based on their parent term, 
    -   The size of the term is proportional to the significance.


**I recommend reading through the full list of significant GSEA terms and selecting the most biologically relevant for better visualisation**

### Gene ontology {.tabset .tabset-pills}

```{r gsea_go}
gsea_go <- readRDS(here::here("0_data/rds_objects/gsea_go.rds"))
```

#### Dot plot

```{r dot_go, fig.width=8, fig.height=10}
dot_go <- ggplot(gsea_go@result[1:25, ]) +
  geom_point(aes(x = tags, y = reorder(Description, tags), colour = logFDR, size = Count, shape = ONTOLOGY %>% as.factor())) +
  scale_color_gradientn(colors = rev(c("#FB8072","#FDB462","#ffffd5","#8DD3C7","#80B1D3")),
                        values = scales::rescale(c(min(gsea_go@result$logFDR), max(gsea_go@result$logFDR))),
                        breaks = scales::pretty_breaks(n = 5)) +
  scale_size(range = c(2,5)) +
  labs(x = "Gene ratio", y = "", color = expression("-log"[10] * "FDR"), size = "Gene Counts", shape = "Ontology")+
  bossTheme(base_size = 14,legend = "right")


tab_go <- gsea_go@result %>%
  dplyr::select(c("Description", "ONTOLOGY", "Count", "enrichmentScore", "NES", "pvalue", "logFDR", "qvalue")) %>% 
  dplyr::mutate_if(is.numeric, funs(as.character(signif(.,3)))) %>% 
  DT(., caption = "Significantly enriched GO terms")

adjGseaPlot <- function(x) {
  x[[1]] <- x[[1]] + bossTheme_bar(14, base_family = "Arial Narrow") + theme(legend.position = c(0.75, 0.8), legend.title = element_blank(), axis.text.x = element_blank(), axis.ticks.x = element_blank())
  x[[2]] <- x[[2]] + bossTheme_bar(14, base_family = "Arial Narrow") + theme(axis.text.x = element_blank(),axis.text.y = element_blank(), axis.ticks = element_blank(), plot.margin = margin(c(0,0,0,0)))
  x[[3]] <- x[[3]] + bossTheme_bar(14)
  return(x)
}

gseaPlot_go <- gseaplot2(gsea_go, geneSetID = 1:5,pvalue_table = F,color = brewer.pal(5,"Set3"),ES_geom = "dot",base_size = 14,rel_heights = c(1.7,0.5,0.8)) %>% adjGseaPlot(.)




if(savePlots == TRUE) {
  ggsave(filename = paste0("gsea_dot_go.svg"), plot = dot_go, path = here::here("2_plots/4_GSEA/go/"),
         width = 18, height = 20, units = "cm")
  ggsave(filename = paste0("gseaPlot_go.svg"), plot = gseaPlot_go, path = here::here("2_plots/4_GSEA/go/"), width = 20, height = 14, units = "cm")
  
}
dot_go
```

#### Table

```{r tab_go}
tab_go
```

#### GSEA plot

```{r gseaPlot_go, fig.width=11, fig.height=9}
gseaPlot_go
```

#### Semantic similarity {.tabset .tabset-dropdown}

##### Dendrogram

```{r semSim_den, fig.width=8, fig.height=11}
treeplot(gsea_go,showCategory = 50, fontsize = 3, cex_category = 0.5,
         cluster.params      = list(method = "ward.D", n = 9, label_words_n = 4, label_format = 30),
         hilight.params      = list(hilight = F, align = "both"),
         clusterPanel.params = list(clusterPanel = "heatMap", pie = "equal", legend_n = 3),
         offset.params       = list(bar_tree = rel(3), tiplab = rel(4), extend = 0.1, hexpand = 0.4)) +
  theme(legend.position = "bottom")
```

##### Scatter plot

Static scatter

```{r semSim_scatter, fig.width = 8, fig.height=8}
simMatrix <- readRDS(here::here("0_data/rds_objects/simMatrix.rds"))
scores <- readRDS(here::here("0_data/rds_objects/scores.rds"))
reducedTerms <- readRDS(here::here("0_data/rds_objects/reducedTerms.rds"))

revigo_dimReduction <- function (simMatrix, reducedTerms, algorithm = c("pca", "umap"), size = "score") {
  
  x <- switch(match.arg(algorithm), pca = cmdscale(as.matrix(as.dist(1 - simMatrix)), eig = TRUE, k = 3)$points, umap = umap::umap(as.matrix(as.dist(1 - simMatrix)),n_components = 3)$layout)
  df <- cbind(as.data.frame(x), reducedTerms[match(rownames(x), reducedTerms$go), c("term", "parent", "parentTerm", size)])
  
  return(df)
}

set.seed(3)
dimReduced <- revigo_dimReduction(simMatrix, reducedTerms, algorithm = "umap")

m <- subset(dimReduced, parent == rownames(dimReduced))[1:15,]

scatter <- ggplot(dimReduced, aes(x = V1, y = V2, color = parentTerm)) +
  geom_point(aes_string(size = "score"), alpha = 0.5, stroke = 0) + 
  scale_color_discrete(guide = "none") +
  # scale_fill_discrete(guide = "none") +
  scale_size_continuous(name = expression("-log"[10] * "FDR"), range = c(0,12)) + 
  scale_x_continuous(name = "UMAP1") +
  scale_y_continuous(name = "UMAP2") +
  guides(x = ggh4x::guide_axis_truncated(trunc_lower = unit(0, "npc"),trunc_upper = unit(3, "cm")), 
         y = ggh4x::guide_axis_truncated(trunc_lower = unit(0, "npc"),trunc_upper = unit(3, "cm"))) +
  geom_label_repel(aes(label = m$parentTerm),data = m, box.padding = grid::unit(1,"lines"), size = 3, label.size = 0.15) + 
  bossTheme(14) +
  theme(
    line = element_blank(),
    rect = element_blank(),
    panel.border = element_blank(),
    axis.text.x = element_blank(),
    axis.text.y = element_blank(),
    axis.ticks = element_blank(),
    legend.position = "right",
    axis.line = element_line(arrow = arrow()),
    axis.title = element_text(hjust = 0),
    axis.title.y = element_text(
      family = "Arial Narrow",
      face = "plain",
      size = 13,
      angle = 90,
      vjust = 1
    ),
    axis.title.x = element_text(
      family = "Arial Narrow",
      face = "plain",
      size = 13,
      angle = 0,
      vjust = 0
    )
  )

scatter

```

Interactive scatter

```{r interactiveScatter, fig.width = 9, fig.height=9}
# a <- list(
#   x = m$V1,
#   y = m$V2,
#   text = m$parentTerm,
#   xref = "x",
#   yref = "y",
#   showarrow = TRUE,
#   arrowhead = 0
# )

ggplotly(scatter + bossTheme(14)) %>% add_markers(size = 5) %>% layout(showlegend = FALSE)
```


3D Interactive scatter


```{r 3d interactive scatter, fig.width = 9, fig.height=9}
plot_ly(dimReduced, x = ~ V1, y = ~ V2, z = ~ V3, color = ~ parentTerm, size = ~ score,
  marker = list(symbol = 'circle', sizemode = 'diameter'),
  sizes = c(5, 70),
  text = ~paste('Term    :', term,'<br>P. Term:', parentTerm, '<br>Sig       :', score),
  hoverinfo = 'text') %>% 
  layout(showlegend = FALSE,
         title = 'Semantically similar GO terms',
         scene = list(xaxis = list(title = 'UMAP 1',
                      gridcolor = 'rgb(255, 255, 255)',
                      zerolinewidth = 1,
                      ticklen = 5,
                      gridwidth = 2),
               yaxis = list(title = 'UMAP 2',
                      gridcolor = 'rgb(255, 255, 255)',
                      zerolinewidth = 1,
                      ticklen = 5,
                      gridwith = 2),
               zaxis = list(title = 'UMAP 3',
                            gridcolor = 'rgb(255, 255, 255)',
                            zerolinewidth = 1,
                            ticklen = 5,
                            gridwith = 2)))
```

##### Treemap plot

```{r semSim_tree, fig.width=8, fig.height=8}
adjTreemap <- function (reducedTerms, size = "score", title = "", ...) {
  treemap::treemap(
    reducedTerms,
    index = c("parentTerm", "term"),
    vSize = size,
    type = "index",
    title = title,
    palette = "Set2",
    fontcolor.labels = c("#EFF4FF","#00000080"),
    bg.labels = 0,
    border.col = "grey10",
    border.lwds = c(1,0.5),
    fontfamily.labels = "Arial Narrow"
  )
}

adjTreemap(reducedTerms)

```

Interactive Tree

```{r interactiveTree, fig.width=9,fig.height=9}
# png(filename=here::here("2_plots/tree.png"),width=20, height=20,units = "cm",res = 900)
# tree <- adjTreemap(reducedTerms)
# dev.off()

library(htmltools)

browsable(
  tagList(
    tags$head(
      tags$style('text.label{font-size: 20px !important}')
    ),
    d3tree3(adjTreemap(reducedTerms), rootname = "General")
  )
)
```

### KEGG {.tabset .tabset-pills}

```{r gsea_kegg}
gsea_kegg <- readRDS(here::here("0_data/rds_objects/gsea_kegg.rds"))
```

#### Dot plot

```{r dot_kegg, fig.width=8, fig.height=10}
dot_kegg <- ggplot(gsea_kegg@result[1:nrow(gsea_kegg@result), ]) +
  geom_point(aes(x = tags, y = reorder(Description, tags), colour = logFDR, size = Count)) +
  scale_color_gradientn(colors = rev(c("#FB8072","#FDB462","#ffffd5","#8DD3C7","#80B1D3")),
                        values = scales::rescale(c(min(gsea_kegg@result$logFDR), max(gsea_kegg@result$logFDR))),
                        breaks = scales::pretty_breaks(n = 5)) +
  scale_size(range = c(2,5)) +
  labs(x = "Gene ratio", y = "", color = expression("-log"[10] * "FDR"), size = "Gene Counts")+
  bossTheme(base_size = 14,legend = "right")


tab_kegg <- gsea_kegg@result %>%
  dplyr::select(c("Description", "Class II", "Count", "enrichmentScore", "NES", "pvalue", "logFDR", "qvalue")) %>% 
  dplyr::mutate_if(is.numeric, funs(as.character(signif(.,3)))) %>% 
  DT(., caption = "Significantly enriched KEGG pathways")

gseaPlot_kegg <- gseaplot2(gsea_kegg, geneSetID = 1:5,pvalue_table = F,color = brewer.pal(5,"Set3"),ES_geom = "dot",base_size = 14, rel_heights = c(1.7,0.5,0.8)) %>% adjGseaPlot(.)


if(savePlots == TRUE) {
  ggsave(filename = paste0("gsea_dot_kegg.svg"), plot = dot_kegg, path = here::here("2_plots/4_GSEA/kegg/"),
         width = 18, height = 20, units = "cm")
  ggsave(filename = paste0("gseaPlot_kegg.svg"), plot = gseaPlot_kegg, path = here::here("2_plots/4_GSEA/kegg/"), width = 20, height = 14, units = "cm")
}

dot_kegg

```

#### Table

```{r tab_kegg}
tab_kegg
```

#### GSEA plot

```{r gseaPlot_kegg, fig.width=11, fig.height=9}
gseaPlot_kegg
```

### Reactome {.tabset .tabset-pills}

```{r gsea_react}
gsea_react <- readRDS(here::here("0_data/rds_objects/gsea_react.rds"))
```

#### Dot plot

```{r dot_react, fig.width=8, fig.height=10}
dot_react <- ggplot(gsea_react@result[1:nrow(gsea_react@result), ]) +
  geom_point(aes(x = tags, y = reorder(Description, tags), colour = logFDR, size = Count)) +
  scale_color_gradientn(colors = rev(c("#FB8072","#FDB462","#ffffd5","#8DD3C7","#80B1D3")),
                        values = scales::rescale(c(min(gsea_react@result$logFDR), max(gsea_react@result$logFDR))),
                        breaks = scales::pretty_breaks(n = 5)) +
  scale_size(range = c(2,5)) +
  labs(x = "Gene ratio", y = "", color = expression("-log"[10] * "FDR"), size = "Gene Counts")+
  bossTheme(base_size = 14,legend = "right")


tab_react <- gsea_react@result %>%
  dplyr::select(c("Description", "Count", "enrichmentScore", "NES", "pvalue", "logFDR", "qvalue")) %>% 
  dplyr::mutate_if(is.numeric, funs(as.character(signif(.,3)))) %>% 
  DT(., caption = "Significantly enriched react terms")

gseaPlot_react <- gseaplot2(gsea_react, geneSetID = 1:5,pvalue_table = F,color = brewer.pal(5,"Set3"),ES_geom = "dot",base_size = 14, rel_heights = c(1.7,0.5,0.8)) %>% adjGseaPlot(.)


if(savePlots == TRUE) {
  ggsave(filename = paste0("gsea_dot_react.svg"), plot = dot_react, path = here::here("2_plots/4_GSEA/reactome/"),
         width = 18, height = 20, units = "cm")
  ggsave(filename = paste0("gseaPlot_react.svg"), plot = gseaPlot_react, path = here::here("2_plots/4_GSEA/reactome/"), width = 20, height = 14, units = "cm")
  
}

dot_react
```

#### Table

```{r tab_react}
tab_react
```

#### GSEA plot

```{r gseaPlot_react, fig.width=11, fig.height=9}
gseaPlot_react
```

# Export Data

The following are exported:

-   **KEGG_all.xlsx** - This spreadsheet contains all KEGG pathways

-   **KEGG_sig.xlsx** - This spreadsheet contains all significant (P value \< 0.05) KEGG pathways

```{r exportData, eval=export}
writexl::write_xlsx(x = list(go = gsea_go@result, kegg = gsea_kegg@result, react = gsea_react@result), here::here("3_output/GSEA.xlsx"))
```
